<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XiaoXian-缘溪行忘路之远近</title>
  
  <subtitle>缘溪行忘路之远近</subtitle>
  <link href="https://codexiaoxian.com/atom.xml" rel="self"/>
  
  <link href="https://codexiaoxian.com/"/>
  <updated>2021-09-30T01:11:09.111Z</updated>
  <id>https://codexiaoxian.com/</id>
  
  <author>
    <name>XiaoXian</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IDEA的一些技巧</title>
    <link href="https://codexiaoxian.com/2021/09/30/IDEA%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7/"/>
    <id>https://codexiaoxian.com/2021/09/30/IDEA%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7/</id>
    <published>2021-09-30T01:08:25.000Z</published>
    <updated>2021-09-30T01:11:09.111Z</updated>
    
    <content type="html"><![CDATA[<p> 持续更新这个帖子</p><h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><ul><li>**psvm **可以快速打出 public static void main（）</li><li>**sout **可以快速打出 System.out.println（）；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 持续更新这个帖子&lt;/p&gt;
&lt;h1 id=&quot;快捷键&quot;&gt;&lt;a href=&quot;#快捷键&quot; class=&quot;headerlink&quot; title=&quot;快捷键&quot;&gt;&lt;/a&gt;快捷键&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;**psvm **可以快速打出 public static void main（）&lt;/</summary>
      
    
    
    
    
    <category term="工具使用" scheme="https://codexiaoxian.com/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>栈和队列</title>
    <link href="https://codexiaoxian.com/2021/09/29/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>https://codexiaoxian.com/2021/09/29/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</id>
    <published>2021-09-29T14:10:00.000Z</published>
    <updated>2021-09-29T14:24:44.856Z</updated>
    
    
    
    
    
    <category term="数据结构笔记" scheme="https://codexiaoxian.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="https://codexiaoxian.com/2021/09/21/%E9%93%BE%E8%A1%A8/"/>
    <id>https://codexiaoxian.com/2021/09/21/%E9%93%BE%E8%A1%A8/</id>
    <published>2021-09-21T14:19:56.000Z</published>
    <updated>2021-10-03T14:36:32.227Z</updated>
    
    <content type="html"><![CDATA[<p> 先附上维基和百度百科：<a href="https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8">链表 - 维基百科，自由的百科全书 (wikipedia.org)</a></p><p>​                                        <a href="https://baike.baidu.com/item/%E9%93%BE%E8%A1%A8/9794473?fr=aladdin">链表_百度百科 (baidu.com)</a></p><p> 大体知识点：</p><ul><li>链表简介</li><li>链表结构的创建</li><li>链表的”增删查改“</li><li>其他有趣的操作</li></ul><p>内容:</p><ol><li>链表介绍</li><li>创建及初始化一个单链表</li><li>测试</li></ol><p>运行环境：<strong>Visual Studio2019</strong></p><h1 id="链表简介"><a href="#链表简介" class="headerlink" title="链表简介"></a>链表简介</h1><p>链表，即<strong>线性表的链式存储</strong>。在数据结构中有两种存储方式：<strong>顺序存储和链式存储</strong>。</p><p>主要种类有：<strong>单链表，双链表（双向链表），循环链表</strong></p><p>简单理解就是<strong>包含指针的数组</strong>，但是和数组不同，链表不是顺序存储在一起的，而是存储在不同的地方，而将它们串联在一起的就是指针这个强大的工具。</p><p>链表有以下几个特点：</p><table><thead><tr><th align="center"></th><th align="center">增（插入）</th><th align="center">删</th><th align="center">查</th><th align="center">改</th></tr></thead><tbody><tr><td align="center">链表</td><td align="center">快 O(1)</td><td align="center">快 O(1)</td><td align="center">O(n)</td><td align="center">快 O(1)</td></tr><tr><td align="center">顺序表</td><td align="center"></td><td align="center"></td><td align="center">快 O(1)</td><td align="center"></td></tr></tbody></table><h3 id="链表术语介绍"><a href="#链表术语介绍" class="headerlink" title="链表术语介绍"></a>链表术语介绍</h3><p>单向链表（单链表)：<a href="https://baike.baidu.com/item/%E5%8D%95%E9%93%BE%E8%A1%A8/3228368?fr=aladdin">单链表_百度百科 (baidu.com)</a>       </p><p>​                                  <a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8">单向链表 - 维基百科，自由的百科全书 (wikipedia.org)</a>  （这里也主要讲单链表）</p><p>结点：</p><p>头指针：</p><p>双向链表（双链表)：</p><p>循环链表</p><h1 id="链表结构的创建"><a href="#链表结构的创建" class="headerlink" title="链表结构的创建"></a>链表结构的创建</h1><p>​    分为以下几个部分：</p><ul><li>链表结构体的搭建（链表的结构）</li><li>链表的初始建立（创建一个新链表）<ol><li>空结点的创建</li><li>链表的创建</li></ol></li><li>链表的几个工具<ol><li>链表的遍历</li><li>链表的结点个数统计</li><li>判断是否为空链表</li></ol></li></ul><h2 id="链表结构体的搭建"><a href="#链表结构体的搭建" class="headerlink" title="链表结构体的搭建"></a>链表结构体的搭建</h2><ul><li><p>链表的结构分为两部分：</p><ol><li>数据域</li><li>指针域</li></ol></li><li><p>前提知识点：</p><ol><li>typedef的使用</li><li>结构体指针</li></ol></li></ul><p>代码实例：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>Elem data;<span class="hljs-comment">//存储的数据</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> * <span class="hljs-title">next</span>;</span><span class="hljs-comment">//那个链接彼此的指针</span><br>&#125;Node, * Link;<span class="hljs-comment">//方便起，typedef起的别名，一个结构体，一个结构体指针</span><br></code></pre></div></td></tr></table></figure><h2 id="链表的初始建立"><a href="#链表的初始建立" class="headerlink" title="链表的初始建立"></a>链表的初始建立</h2><p>先来说说<strong>一个空结点</strong>的创建和初始化</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function">Link <span class="hljs-title">cn</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br>    <span class="hljs-comment">//动态分配</span><br>Link node = (Link)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Node));<br>    <span class="hljs-comment">//判断是否分配成功</span><br><span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;分配失败&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br>    <span class="hljs-comment">//初始化</span><br>node-&gt;data = <span class="hljs-number">0</span>;<br>node-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <br><span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>链表的创建，这里分为两个方法：<strong>头插法</strong> 和<strong>尾插法</strong></p><p>先来说尾插法：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function">Link <span class="hljs-title">creat_node_1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>Link head = cn();<br>    <span class="hljs-comment">//传递结点</span><br>Link rear = head;<br>    <span class="hljs-comment">//创建新结点进行赋值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<span class="hljs-comment">//len个结点</span><br>Link p = cn();<br>scanf_s(<span class="hljs-string">&quot;%d&quot;</span>, &amp;p-&gt;data);<br><span class="hljs-comment">//核心语句</span><br>rear-&gt;next = p;<br>rear = p;<br>&#125;rear-&gt;next = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>尾插法的优点：<strong>插入时的顺序是正常的</strong>；</p><p>再来说说头插法：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//头插法，创建链表</span><br><span class="hljs-function">Link <span class="hljs-title">creat_node_2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>Link head = cn();<br><span class="hljs-comment">//</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>Link p = cn();<br>p-&gt;data = scanf_s(<span class="hljs-string">&quot;%d&quot;</span>, &amp;p-&gt;data);<br><span class="hljs-comment">//核心语句</span><br>p-&gt;next = head-&gt;next;<br>head-&gt;next = p;<br>&#125;<br><span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>头插法的缺点：插入的结点的<strong>顺序是反的</strong>（可以想想链表的逆置）</p><h2 id="链表的遍历（打印）"><a href="#链表的遍历（打印）" class="headerlink" title="链表的遍历（打印）"></a>链表的遍历（打印）</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_list</span><span class="hljs-params">(Link head)</span> </span>&#123;<br>    <br>Link p = head-&gt;next;<span class="hljs-comment">//从第一个结点开始</span><br><span class="hljs-keyword">while</span> (p) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, p-&gt;data);<br>p = p-&gt;next;<span class="hljs-comment">//下一个结点</span><br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="链表的元素个数的统计（打印）"><a href="#链表的元素个数的统计（打印）" class="headerlink" title="链表的元素个数的统计（打印）"></a>链表的元素个数的统计（打印）</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//打印链表结点数量</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">print_num</span><span class="hljs-params">(Link head)</span> </span>&#123;<br><span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>Link p = cn();<br>p = head-&gt;next;<br><span class="hljs-keyword">while</span> (p) &#123;<br>num++;<br>p = p-&gt;next;<br>&#125;<br><span class="hljs-keyword">return</span> num;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="判断是否为空链表"><a href="#判断是否为空链表" class="headerlink" title="判断是否为空链表"></a>判断是否为空链表</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">is_empty</span><span class="hljs-params">(Link head)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (head-&gt;next == <span class="hljs-literal">NULL</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="链表的”增删查改“"><a href="#链表的”增删查改“" class="headerlink" title="链表的”增删查改“"></a>链表的”增删查改“</h1><p>分为以下几个：</p><ul><li>链表结点的查找</li><li>链表结点的删除</li><li>链表结点的新增</li><li>链表结点的更改</li></ul><h2 id="增（插入）"><a href="#增（插入）" class="headerlink" title="增（插入）"></a>增（插入）</h2><ul><li>其内容大体与链表的创建类似</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//插入</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">import</span><span class="hljs-params">(Link head, <span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> no)</span> </span>&#123;<span class="hljs-comment">//num:插入的数据内容；no:插入的位置</span><br>Link p = cn();<br>p-&gt;data = num;<br>p-&gt;next = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">if</span> (no == <span class="hljs-number">1</span>) &#123;<br>p-&gt;next = head-&gt;next;<br>head-&gt;next = p;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; Link q = head;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; no; i++) &#123;<br>q = head-&gt;next;<br>&#125;<br><span class="hljs-comment">//核心语句</span><br>p-&gt;next = q-&gt;next;<br>q-&gt;next = p;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="删（删除）"><a href="#删（删除）" class="headerlink" title="删（删除）"></a>删（删除）</h2><ul><li>这里分为两种：按位置删  和   按数值删</li></ul><ol><li>先来说说按位置删：</li></ol><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//删除指定结点(位置)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">del_node</span><span class="hljs-params">(Link head, <span class="hljs-keyword">int</span> num)</span><span class="hljs-comment">//可能要操作表头指针，所以head是引用</span></span><br><span class="hljs-function"></span>&#123;<br>Link p = head;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; p-&gt;next != <span class="hljs-literal">NULL</span> &amp;&amp; i &lt; num - <span class="hljs-number">1</span>; i++) &#123;<br>p = p-&gt;next;<br>&#125;<br><br><span class="hljs-keyword">if</span> (p-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;数目不存在！程序退出\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//核心代码</span><br>Link q = p-&gt;next;<span class="hljs-comment">//为了好清理空间</span><br>p-&gt;next = p-&gt;next-&gt;next;<br><span class="hljs-built_in">free</span>(q);<br>&#125;<br></code></pre></div></td></tr></table></figure><ol start="2"><li>再来说说按数值删：</li></ol><p>（这里注意只能删掉第一数值的结点)</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//删除指定结点(数值)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">del_node_num</span><span class="hljs-params">(Link head, <span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>Link p = head-&gt;next;<br><br><span class="hljs-keyword">while</span> (p-&gt;next-&gt;data != num &amp;&amp; p-&gt;next != <span class="hljs-literal">NULL</span>) &#123;<br>p-&gt;next = p-&gt;next-&gt;next;<br>&#125;<br><br><span class="hljs-keyword">if</span> (p-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;数目不存在！程序退出\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//核心代码</span><br>Link q = p-&gt;next;<br>p-&gt;next = p-&gt;next-&gt;next;<br><span class="hljs-built_in">free</span>(q);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="查（查找）"><a href="#查（查找）" class="headerlink" title="查（查找）"></a>查（查找）</h2><p>同样分为两种：<strong>按位置查数值</strong>和<strong>按数值查位置</strong></p><p>先来<strong>按位置查数值</strong></p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//删除指定结点(位置)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">del_node</span><span class="hljs-params">(Link head, <span class="hljs-keyword">int</span> num)</span><span class="hljs-comment">//可能要操作表头指针，所以head是引用</span></span><br><span class="hljs-function"></span>&#123;<br>Link p = head;<br><span class="hljs-comment">//确定位置</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; p-&gt;next != <span class="hljs-literal">NULL</span> &amp;&amp; i &lt; num - <span class="hljs-number">1</span>; i++) &#123;<br>p = p-&gt;next;<br>&#125;<br><span class="hljs-comment">//防止溢出</span><br><span class="hljs-keyword">if</span> (p-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;数目不存在！程序退出\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//核心代码</span><br>Link q = p-&gt;next;<span class="hljs-comment">//为了好清理空间</span><br>p-&gt;next = p-&gt;next-&gt;next;<br><span class="hljs-built_in">free</span>(q);<span class="hljs-comment">//清理空间</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>再来按<strong>数值查位置</strong></p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//查找数值，返回位置</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search_node</span><span class="hljs-params">(Link head, <span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>Link p = head-&gt;next;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (p-&gt;data != num &amp;&amp; p-&gt;next != <span class="hljs-literal">NULL</span>) &#123;<br>p = p-&gt;next;<br>i++;<br>&#125;<br><br><span class="hljs-keyword">if</span> (p-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;数目不存在！程序退出\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="改（修改结点数据）"><a href="#改（修改结点数据）" class="headerlink" title="改（修改结点数据）"></a>改（修改结点数据）</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//修改结点数值</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change_node</span><span class="hljs-params">(Link head, <span class="hljs-keyword">int</span> no, <span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>Link p = head;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; no &amp;&amp; p-&gt;next != <span class="hljs-literal">NULL</span>; i++) &#123;<br>p = p-&gt;next;<br>&#125;<br><br><span class="hljs-keyword">if</span> (p-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;数目不存在！程序退出\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>p-&gt;data = num;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="其他有趣的操作"><a href="#其他有趣的操作" class="headerlink" title="其他有趣的操作"></a>其他有趣的操作</h1><ul><li>逆序</li></ul><h2 id="逆序"><a href="#逆序" class="headerlink" title="逆序"></a>逆序</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//逆置 ,头插法版</span><br><span class="hljs-function">Link <span class="hljs-title">nz</span><span class="hljs-params">(Link head, <span class="hljs-keyword">int</span> len)</span> </span>&#123;<br><br>Link p = head-&gt;next; <span class="hljs-comment">//寻找指针</span><br>Link h = cn(); <span class="hljs-comment">//返回的头指针</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>Link q = cn();<br>q-&gt;data = p-&gt;data;<br><br>q-&gt;next = h-&gt;next;<br>h-&gt;next = q;<br>p = p-&gt;next;<br>&#125;<br><span class="hljs-keyword">return</span> h;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>主要就是<strong>main()函数</strong>来进行测试；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 先附上维基和百度百科：&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%93%BE%E8%A1%A8&quot;&gt;链表 - 维基百科，自由的百科全书 (wikipedia.org)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;​                    </summary>
      
    
    
    
    
    <category term="数据结构笔记" scheme="https://codexiaoxian.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数据结构C语言预备知识</title>
    <link href="https://codexiaoxian.com/2021/09/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"/>
    <id>https://codexiaoxian.com/2021/09/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/</id>
    <published>2021-09-21T05:56:23.000Z</published>
    <updated>2021-09-21T07:51:08.592Z</updated>
    
    <content type="html"><![CDATA[<p>讲讲数据结构中C语言的相关前提知识，不涉及循环、分支之类特别基础的知识。</p><p>知识点如下：</p><ul><li><p><strong>结构体struct</strong></p></li><li><p><strong>指针与结构体指针</strong></p></li><li><p><strong>typedef起别名</strong></p></li><li><p><strong>malloc( )函数</strong></p></li></ul><h2 id="结构体struct"><a href="#结构体struct" class="headerlink" title="结构体struct"></a>结构体struct</h2><ul><li><p>结构体类似于普通的标识符（如int,double),只不过在定义的时候需要在前面加上struct</p></li><li><p>结构体的初始化</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LN</span> &#123;</span><span class="hljs-comment">//结构体的标签，类似于 int ;不过对于结构体而言定义时要 struct LN;(在前面加上struct) , </span><br><span class="hljs-comment">//结构体具体内容如</span><br>    <span class="hljs-keyword">int</span> num;<br>    <span class="hljs-keyword">char</span>[MAX] name;<br>&#125;no = &#123;...), np =&#123;...&#125;;<span class="hljs-comment">//对于任何表示这个新结构时都要 在前面加上struct </span><br><span class="hljs-comment">//结构体的定义与初始化,注意在这里不能定义什么 *p 之类的，因为是定义新结构体数据 </span><br></code></pre></div></td></tr></table></figure></li><li><p>在其他地方使用</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LN</span> <span class="hljs-title">np</span> =</span> &#123;...&#125;;      <span class="hljs-comment">//道理一样</span><br></code></pre></div></td></tr></table></figure></li></ul><h2 id="指针与结构体指针"><a href="#指针与结构体指针" class="headerlink" title="指针与结构体指针"></a>指针与结构体指针</h2><p>先贴个阮一峰大神的详细讲解：<a href="https://wangdoc.com/clang/pointer.html">指针 - C 语言教程 - 网道 (wangdoc.com)</a>，底下说说自己的理解</p><ul><li><p>指针变量指向的是一个地址，如：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span> * p = &amp;q; <span class="hljs-comment">// 这里的p(注意不是*p)存储的就是q的地址，而*p就会代表q,*p的改动也会改动q</span><br></code></pre></div></td></tr></table></figure></li><li><p>结构体指针同理，结构体指针就是指向一个结构体数据，如：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">p</span>;</span> <span class="hljs-comment">//注意：新建的结构体数据（包括指针）在最前面都要加上struct才可建立</span><br></code></pre></div></td></tr></table></figure></li></ul><h2 id="typedef起别名"><a href="#typedef起别名" class="headerlink" title="typedef起别名"></a>typedef起别名</h2><p>这里先说一下**#define**（宏替换），typedef与其类似，但不是简单替换，而是直接代替。</p><p>并且typedef相比于#define来说范围更广，主要是用来替换结构体标识符，如：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> newint;<span class="hljs-comment">//这里就可以用Elem来表示int，注意这里只能给int起一个别名</span><br><br>Elem num = <span class="hljs-number">1</span>;<span class="hljs-comment">//等同于int num = 1;</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> * np;<span class="hljs-comment">//还可以给指针标识符起名</span><br>np n, m;<span class="hljs-comment">//还可以定义多个指针变量，等同于int *n, *m;(注意区别！用np不用*了，想一下如果用#define int* np 的结果)</span><br>n = &amp;num;<span class="hljs-comment">//使用起来和正常定义没有区别</span><br></code></pre></div></td></tr></table></figure><p>当然除了这种普通的起别名，也是可以给结构体来起别名；如：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//使用typedef   </span><br>*<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LN</span>&#123;</span><br>&#125;LNode, *Link, op;<span class="hljs-comment">//使用了typedef 可以直接在这里起一个 结构体指针新名字，此时LN是可以省掉的</span><br><br>LNode p;<span class="hljs-comment">//用 typedef 起的LNode这个新结构的新名字可以直接 LNode p;来定义新结构体</span><br>Link m;<span class="hljs-comment">//这里也可以直接用 Link 来直接定义一个结构体指针了</span><br>op p;<span class="hljs-comment">//与普通int起别名不同，结构体起别名，可以起多个名字,这里op p;等同于LNode p;等同于struct LN p;</span><br>  <br><span class="hljs-comment">/********************注*****意**************************************************************/</span><br><span class="hljs-comment">//当使用了typedef 给LN 这个新结构起了别名时，struct 后的标签依旧可以用struct LN p; 来定义新的结构体数据,</span><br><span class="hljs-comment">//typedef 后，定义时是是不可以 struct LNode p; 的，只可直接 LNode p; </span><br><span class="hljs-comment">//与普通int起别名不同，结构体起别名，可以起多个名字</span><br></code></pre></div></td></tr></table></figure><h2 id="malloc-函数"><a href="#malloc-函数" class="headerlink" title="malloc( )函数"></a>malloc( )函数</h2><p>malloc()函数介绍：<a href="https://baike.baidu.com/item/malloc%E5%87%BD%E6%95%B0">malloc函数_百度百科 (baidu.com)</a></p><p>​                    用法：<a href="https://www.runoob.com/cprogramming/c-function-malloc.html">C 库函数 – malloc() | 菜鸟教程 (runoob.com)</a></p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">指针数据类型如<span class="hljs-keyword">char</span>* p =  (和分配的数据的类型一样如<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(数据类型)分配多大空间);<br></code></pre></div></td></tr></table></figure><ul><li>简单来说说我的理解</li><li><ol><li>一定是指针型的，不然空间地址给谁，分配不到不然</li><li>一定是同类型指针，char * 就对应malloc前面的 char * </li><li>分配一定的空间由malloc后面括号里的数值决定，一般由sizeof( )函数决定</li></ol></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;讲讲数据结构中C语言的相关前提知识，不涉及循环、分支之类特别基础的知识。&lt;/p&gt;
&lt;p&gt;知识点如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;结构体struct&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;指针与结构体指针&lt;/strong&gt;&lt;</summary>
      
    
    
    
    
    <category term="数据结构笔记" scheme="https://codexiaoxian.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>GitHub使用</title>
    <link href="https://codexiaoxian.com/2021/09/19/GitHub%E4%BD%BF%E7%94%A8/"/>
    <id>https://codexiaoxian.com/2021/09/19/GitHub%E4%BD%BF%E7%94%A8/</id>
    <published>2021-09-19T09:52:11.000Z</published>
    <updated>2021-09-30T04:59:41.203Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初识Git和GitHub"><a href="#初识Git和GitHub" class="headerlink" title="初识Git和GitHub"></a>初识Git和GitHub</h1><p><strong>WIKI</strong>:<a href="https://zh.wikipedia.org/wiki/Git">git - 维基百科，自由的百科全书 (wikipedia.org)</a></p><p>​         <a href="https://zh.wikipedia.org/wiki/GitHub">GitHub - 维基百科，自由的百科全书 (wikipedia.org)</a></p><p><strong>百度</strong>：<a href="https://baike.baidu.com/item/GIT/12647237?fr=aladdin">GIT（分布式版本控制系统）_百度百科 (baidu.com)</a></p><p>​     <a href="https://baike.baidu.com/item/Github">Github_百度百科 (baidu.com)</a></p><h1 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h1><ul><li>可以在bash命令窗口中输入git来进行查看命令指令</li></ul><h2 id="如何Clone一个仓库"><a href="#如何Clone一个仓库" class="headerlink" title="如何Clone一个仓库"></a>如何Clone一个仓库</h2><p>首先在要下载到的文件夹下右击选择<strong>Git Bash</strong>，输入：：</p><p><strong>git clone https://……..(你要clone的仓库复制的地址) (空格(你准备建立的文件夹名)</strong></p><p>“举个栗子”:</p><figure class="highlight plaintext"><figcaption><span>git clone</span><a href="https://github.com/xiaolei565/aimto408.git">kaoyan/408</a></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs $">$ git clone https://github.com/xiaolei565/aimto408.git kaoyan/408<br></code></pre></div></td></tr></table></figure><ol><li>地址在那边找？怎么复制？在你打开的仓库的右上方有个绿色的<strong>CODE</strong>键，点击它，再点击一下地址旁边草稿本样的图标，你就可以复制下来仓科地址了</li><li>一定要在下载到的文件夹下操作？是的，建议这样做。即是你熟悉命令行也要在要下载到的文件夹中进行git操作</li><li>文件夹只能一个？不是的，你可以用**/**来建立“文件夹中的文件夹”</li></ol><h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><p><strong>Repository</strong>：简称Repo，可以理解为“仓库”，我们的项目就存放在仓库之中。如果想要建立项目，就得先建立仓库；有多个项目，就建立多个仓库。</p><p><strong>Issues</strong>：可以理解为“问题”，举一个简单的例子，如果我们开源一个项目，如果别人看了我们的项目，并且发现了bug，或者感觉那个地方有待改进，他就可以给我们提出Issue，等我们把Issues解决之后，就可以把这些Issues关闭；反之，我们也可以给他人提出Issue。</p><p><strong>Star</strong>：可以理解为“点赞”收藏“，当我们感觉某一个项目做的比较好之后，就可以为这个项目点赞，而且我们点赞过的项目，都会保存到我们的Star之中，方便我们随时查看。在 GitHub 之中，如果一个项目的点星数能够超百，那么说明这个项目已经很不错了。</p><p><strong>Fork</strong>：可以理解为“拉分支”，复制一份到我们的仓库中，如果我们对某一个项目比较感兴趣，并且想在此基础之上开发新的功能，这时我们就可以Fork这个项目，这表示复制一个完成相同的项目到我们的 GitHub 账号之中，而且独立于原项目。之后，我们就可以在自己复制的项目中进行开发了。</p><p><strong>Pull Request</strong>：可以理解为“提交请求”，此功能是建立在Fork之上的，如果我们Fork了一个项目，对其进行了修改，而且感觉修改的还不错，我们就可以对原项目的拥有者提出一个Pull请求，等其对我们的请求审核，并且通过审核之后，就可以把我们修改过的内容合并到原项目之中，这时我们就成了该项目的贡献者。</p><p><strong>Merge：</strong>可以理解为“合并”，如果别人Fork了我们的项目，对其进行了修改，并且提出了Pull请求，这时我们就可以对这个Pull请求进行审核。如果这个Pull请求的内容满足我们的要求，并且跟我们原有的项目没有冲突的话，就可以将其合并到我们的项目之中。当然，是否进行合并，由我们决定。</p><p><strong>Watch：</strong>可以理解为“观察”，如果我们Watch了一个项目，之后，如果这个项目有了任何更新，我们都会在第一时候收到该项目的更新通知。</p><p><strong>Gist：</strong>如果我们没有项目可以开源或者只是单纯的想分享一些代码片段的话，我们就可以选择Gist。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;初识Git和GitHub&quot;&gt;&lt;a href=&quot;#初识Git和GitHub&quot; class=&quot;headerlink&quot; title=&quot;初识Git和GitHub&quot;&gt;&lt;/a&gt;初识Git和GitHub&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;WIKI&lt;/strong&gt;:&lt;a href=</summary>
      
    
    
    
    
    <category term="工具使用" scheme="https://codexiaoxian.com/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>这篇blog是怎么来的</title>
    <link href="https://codexiaoxian.com/2021/09/19/%E9%80%9A%E8%BF%87Hexo%E5%92%8CGithub%E6%9D%A5%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%85%8D%E8%B4%B9%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://codexiaoxian.com/2021/09/19/%E9%80%9A%E8%BF%87Hexo%E5%92%8CGithub%E6%9D%A5%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%85%8D%E8%B4%B9%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2021-09-19T02:53:06.000Z</published>
    <updated>2021-09-21T05:55:30.754Z</updated>
    
    <content type="html"><![CDATA[<h1 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h1><p>搭建博客推荐教程：<a href="https://www.cnblogs.com/zhcncn/p/4097881.html">Hexo搭建Github静态博客 - 金石开 - 博客园 (cnblogs.com)</a></p><h2 id="必要软件"><a href="#必要软件" class="headerlink" title="必要软件"></a>必要软件</h2><ul><li><a href="https://nodejs.org/zh-cn/">Node.js (nodejs.org)</a></li><li><a href="https://git-scm.com/">Git (git-scm.com)</a></li><li><a href="https://hexo.io/zh-cn/">Hexo</a></li><li>安装npm和cnpm</li></ul><h2 id="必要资料"><a href="#必要资料" class="headerlink" title="必要资料"></a>必要资料</h2><p>博客搭建：参考hexo官方中文网站：<a href="https://hexo.io/zh-cn/docs/">文档 | Hexo</a></p><p>主题设置：主题的官方文档：如：<a href="https://hexo.fluid-dev.com/docs/start/">开始使用 | Hexo Fluid (fluid-dev.com)</a></p><p>主题寻找：<a href="https://github.com/search?q=hexo-theme">Search · hexo-theme (github.com)</a></p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li><p>git的<strong>SSH-key</strong>问题（非常重要，否则上传不了，<strong>第一次使用要配置</strong>）</p></li><li><p>目录问题，如是在blog文件下进行操作还是在themes文件下操作</p></li><li><p>在预览后（<strong>hexo s</strong>)记得<strong>CTRL + C</strong>退出，否则会出错</p></li><li><p>Node_JS 的环境变量配置</p></li><li><p>Hexo的版本注意（不同的版本的设置略微不同，如要求ssh还是http）</p><ul><li>我的Hexo是4.3.0 在最后的设置就要是 <a href="mailto:&#x67;&#105;&#x74;&#64;&#103;&#x69;&#x74;&#104;&#x75;&#x62;&#x2e;&#99;&#111;&#109;">&#x67;&#105;&#x74;&#64;&#103;&#x69;&#x74;&#104;&#x75;&#x62;&#x2e;&#99;&#111;&#109;</a>……..而不是<a href="https://github.com/">https://github.com</a>……..</li></ul></li></ul><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><h2 id="Hexo命令"><a href="#Hexo命令" class="headerlink" title="Hexo命令"></a>Hexo命令</h2><p>建议自己看官方网站<a href="https://hexo.io/zh-cn/docs/commands">指令 | Hexo</a>,这边举几个常用例子</p><ul><li><strong>hexo d</strong> : 上传博客（deploy）</li><li><strong>hexo s</strong> :  预览（记得<strong>CTRL + C</strong>）</li><li><strong>hexo clean</strong> : 清除缓存</li><li><strong>hexo new “….”</strong> : 新建一个博文</li><li><strong>hexo init</strong> : 初始化博客</li></ul><h2 id="版本号查看命令"><a href="#版本号查看命令" class="headerlink" title="版本号查看命令"></a>版本号查看命令</h2><ul><li>git 版本：git –version</li><li>node_js版本 : node -v</li><li>其他 版本：名字 -v   如：hexo -v</li></ul><h1 id="自定义网站域名"><a href="#自定义网站域名" class="headerlink" title="自定义网站域名"></a>自定义网站域名</h1><p>GitHub_Page的**.github.io**有时让人感觉不够私人与geek</p><p>这里先购买自己的域名，然后在GitHub自己的blog仓库里setting中的page里设置</p><ul><li>注意这样是不够的，因为每次deploy都要重新设置，很烦，但好在hexo是可以设置的</li><li><ol><li>在博客的**_config.yml**中设置url为自己的域名</li><li>在博客文件夹中的根目录（sourse)文件夹中添加<strong>CNAME</strong>不要加后缀(用记事本就好)，在里面写上自己的域名</li><li>要在域名的<strong>DNS解析器</strong>中设置好。一个A，是IP4地址，一个CNAME，是原先****.github.io的的全名</li></ol></li></ul><h1 id="自己遇到其他的一些”坑”"><a href="#自己遇到其他的一些”坑”" class="headerlink" title="自己遇到其他的一些”坑”"></a>自己遇到其他的一些”坑”</h1><ul><li><p>换了个next theme后，执行任何hexo命令后都会得到一个Error提示：</p><p>Cannot find module ‘hexo-util’  ： 运行一个命令安装下就可以：npm install hexo-util –save</p></li></ul><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul><li>查看他人博客网页主题 ： 右击查看源码，ctrl + f 查找 搜索theme</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;搭建&quot;&gt;&lt;a href=&quot;#搭建&quot; class=&quot;headerlink&quot; title=&quot;搭建&quot;&gt;&lt;/a&gt;搭建&lt;/h1&gt;&lt;p&gt;搭建博客推荐教程：&lt;a href=&quot;https://www.cnblogs.com/zhcncn/p/4097881.html&quot;&gt;Hexo搭</summary>
      
    
    
    
    
    <category term="blog那些事" scheme="https://codexiaoxian.com/tags/blog%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://codexiaoxian.com/2021/09/18/hello-world/"/>
    <id>https://codexiaoxian.com/2021/09/18/hello-world/</id>
    <published>2021-09-18T12:53:14.101Z</published>
    <updated>2021-09-21T03:28:22.388Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="http://www.codexiaoxian.com/">my blog</a>! This is my very first post.I will show my good ideas in this.Welcom to favorite this pages. If you get any problems  or find something wrong when read my post, you can find me by E-mail or you can ask me on <a href="https://github.com/ssss1001/">GitHub</a>.</p><p>Enjoy!</p><h1 id="搭建个人博客记"><a href="#搭建个人博客记" class="headerlink" title="搭建个人博客记"></a>搭建个人博客记</h1><p>其实对于个人博客早有耳闻，在大一下半年就想搭建一个个人博客了，但是在大概看了下羊哥和frank的视频后感觉云里雾里，好像很难的样子，什么hexo构架，什么GitHub，听起来就已经是技术范满满（对我来说），但在这周不知为何就想起来搭建一个博客，我自己都有些感到奇怪。就上网细看教程，细细研究，还真弄了个大概。</p><p>在这个博客的选择上我选用了主流的<strong>Hexo</strong>+<strong>GitHub</strong>的方法，也就是基于GitHub_Page的方案，选用这个方案一来教程多对我这种刚踏入计算机行业的小萌新友好太多，二来静态网页，不用操太多的心在维护上，三来搭建在GitHub上，不用花高昂的价格去购买云服务器。可以说这个方法是可以保证自己能专注于写博客上，而非陷入一种技术怪圈上。</p><p>为什么搭建它，其实我想了一下，可能最初出发点是因为个人博客是可以为简历加分的一项吧，并且个人博客确实是一种geek范十足的一件事。但，过后我觉得在这里，我要做的是记录，不是生活流水账，而是学习日记，一些自己的总结在这个自己自己野心十足的地方。而不是个人空间，朋友圈。</p><p>来举个“栗子”吧！比如最近的数据结构的链表，我就很想总结总结，也确实有太多总结了。</p><p>本来在<strong>freenom</strong>上我拿下了几个免费域名，但在今天（21-09-20）我下了决心还是买了一个属于自己域名（其实更应该叫做租）。主要因为百度等搜索引擎不收录这就有时候很麻烦了。看了几个人的个人博客也差不多是<strong>自定义域名+GitHub_Page+Hexo/主流blog框架+主题</strong>。挺好！</p><p>希望自己能持之以恒写下去，那些学习/技术总结。</p><p>不出意料，这应该会是唯一一篇在这里的日记式博客了。</p><p>See You!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;http://www.codexiaoxian.com/&quot;&gt;my blog&lt;/a&gt;! This is my very first post.I will show my good ideas in this.Welcom to fav</summary>
      
    
    
    
    
    <category term="杂记" scheme="https://codexiaoxian.com/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
</feed>
